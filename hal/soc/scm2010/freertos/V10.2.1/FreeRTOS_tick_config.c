/*
 * FreeRTOS Kernel V10.2.1
 * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "FreeRTOS_tick_config.h"
#include "hal/compiler.h"

#include <hal/types.h>
#include <hal/pinctrl.h>
#include <hal/console.h>

volatile uint64_t * const pullMtimeRegister    = ( volatile uint64_t * const ) ( configMTIME_BASE_ADDRESS );
volatile uint64_t * pullMtimecmpRegister;

#if( configUSE_TICKLESS_IDLE != 0 )
	/* Flag set from the timer interrupt to allow the sleep processing to know if
	sleep mode was exited because of a tick interrupt, or an interrupt
	generated by something else. */
	volatile BaseType_t xTickFlag = pdFALSE;
#endif

#if configUSE_TICKLESS_IDLE == 1

#ifdef CONFIG_LINK_TO_ROM
extern TickType_t xTickCount, xNextTaskUnblockTime;
#endif

void _vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
{
	/* The maximum number of tick periods that can be suppressed is limited by
	   the resolution of the Timer */
#define portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS ( (1ULL << 60) / uxTimerIncrementsForOneTick )

	/* Unit: cycle */
	uint64_t ullNextTickTime, ullWakeUpTime, ullCurrentTime;

	/* Unit: tick */
	TickType_t xCompleteTickPeriods, xTickPeriodsBeforeWakeup, xModifiableIdleTime;

	/* To avoid integer overflow when assigning maximum tick periods
	   to xExpectedIdleTime, check portMAX_DELAY first.
	   p.s. xExpectedIdleTime is always lower than portMAX_DELAY */
	if( portMAX_DELAY > portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS )
	{
		/* if portMAX_DELAY > portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS, then the
		   size of TickType_t is larger than or equal to maximum tick periods */
		if( xExpectedIdleTime > portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS )
		{
			xExpectedIdleTime = (TickType_t) portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS;
		}
	}

	/* Stop mtime interrupt */
	ullNextTickTime = prvStopMtimeIrq();

	/* Calculate the mtimecmp value to wait xExpectedIdleTime tick periods.
	   Wakeup time is at ( xExpectedIdleTime - 1 ) ticks after next tick. */
	ullWakeUpTime = ullNextTickTime + ( ( xExpectedIdleTime - 1 ) * (uint64_t)uxTimerIncrementsForOneTick );

	prvMIE_DISABLE();

	if( eTaskConfirmSleepModeStatus() == eAbortSleep )
	{
		/* Set reload value and restart timer */
		prvWriteMtimecmp( ullNextTickTime );

		/* Re-enable interrupts. */
		prvMIE_ENABLE();
	}
	else
	{
		/* The tick flag is set to false before sleeping. If it is true when
		   sleep mode is exited then sleep mode was probably exited because the
		   tick was suppressed for the entire xExpectedIdleTime period. */
		xTickFlag = pdFALSE;

		/* Set wakeup time and restart timer. Also prepare next mtimecmp value
		   for Timer ISR. */
		prvWriteMtimecmp( ullWakeUpTime );
		ullNextTime = ullWakeUpTime + uxTimerIncrementsForOneTick;

		/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
		   set its parameter to 0 to indicate that its implementation contains
		   its own wait for interrupt or wait for event instruction, and so wfi
		   should not be executed again.  However, the original expected idle
		   time variable must remain unmodified, so a copy is taken. */
		xModifiableIdleTime = xExpectedIdleTime;
		configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
		if( xModifiableIdleTime > 0 )
		{
			__asm volatile( "wfi" );
		}
		configPOST_SLEEP_PROCESSING( xExpectedIdleTime );

		/* Re-enable interrupts to allow the interrupt that brought the MCU
		   out of sleep mode to execute immediately. */
		prvMIE_ENABLE();

		/* Disable interrupts again to avoid timer ISR runs after checking
		   xTickFlag. */
		prvMIE_DISABLE();

		if( xTickFlag == pdTRUE )
		{
			/* As the pending tick will be processed as soon as this
			   function exits, the tick value maintained by the tick is stepped
			   forward by one less than the time spent waiting. */
			xCompleteTickPeriods = xExpectedIdleTime - 1;

			/* Note: mtimecmp is correct in this condition, so we doesn't
			   need to access it */
		}
		else
		{
			ullCurrentTime = prvReadMtime();

			if( ullCurrentTime >= ullWakeUpTime )
			{
				/* Tick interrupt is pending because it occurs after
				   disabling MIE. The tick value is stepped forward by
				   the time spent waiting. */
				xCompleteTickPeriods = xExpectedIdleTime;
			}
			else
			{
				/* Something other than the tick interrupt ended the sleep.
				   Work out how long the sleep lasted rounded to complete tick
				   periods. */

				/* Round up the tick period before wakeup to the Tick unit */
				xTickPeriodsBeforeWakeup = ( ullWakeUpTime - ullCurrentTime - 1 ) / uxTimerIncrementsForOneTick + 1;

				/* To prevent xTickPeriodsBeforeWakeup > xExpectedIdleTime causes xCompleteTickPeriods abnormal */
				if (xTickPeriodsBeforeWakeup > xExpectedIdleTime) {
					printk("Unexpected Tick Periods: %d (%d)\n",xTickPeriodsBeforeWakeup, xExpectedIdleTime);
					xTickPeriodsBeforeWakeup = xExpectedIdleTime;
				}
				xCompleteTickPeriods = xExpectedIdleTime - xTickPeriodsBeforeWakeup;
			}

			ullNextTime = ullNextTickTime + ( ( ( uint64_t ) xCompleteTickPeriods ) * uxTimerIncrementsForOneTick );
			prvWriteMtimecmp( ullNextTime );

			/* Prepare next mtimecmp value for Timer ISR. */
			ullNextTime += ( uint64_t ) uxTimerIncrementsForOneTick;
		}

#ifdef CONFIG_LINK_TO_ROM
		/* Avoid assertion because we have nothing
		 * to do about it at this point.
		 */
		if (xTickCount + xCompleteTickPeriods > xNextTaskUnblockTime) {
			printk("Slept too long: %d ticks over\n",
					xTickCount + xCompleteTickPeriods - xNextTaskUnblockTime);
			xCompleteTickPeriods -= (xTickCount + xCompleteTickPeriods - xNextTaskUnblockTime);
		}
#endif

		vTaskStepTick( xCompleteTickPeriods );

		/* Exit with interrpts enabled. */
		prvMIE_ENABLE();
	}
}

#else

void _vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
{
	(void) xExpectedIdleTime;
}

#endif /*configUSE_TICKLESS_IDLE == 1 */

#ifdef CONFIG_LINK_TO_ROM
PROVIDE(vPortSuppressTicksAndSleep, &vPortSuppressTicksAndSleep, &_vPortSuppressTicksAndSleep);
#else
__func_tab__ void (*vPortSuppressTicksAndSleep)( TickType_t xExpectedIdleTime ) = _vPortSuppressTicksAndSleep;
#endif


/*
 * Create implementation of vPortSetupTimerInterrupt() if the CLINT is not
 * available, but make sure the configCLINT_BASE_ADDRESS constant is still
 * defined.
 */
void vPortSetupTimerInterrupt( void )
{
    uint8_t hart_id = __nds__mfsr(NDS_MHARTID);

    pullMtimecmpRegister = ( volatile uint64_t *) ( configMTIME_BASE_ADDRESS + 8 * (1 + hart_id) );

	ullNextTime = prvReadMtime();
	ullNextTime += ( uint64_t ) uxTimerIncrementsForOneTick;
	*pullMtimecmpRegister = ullNextTime;

	/* Prepare the time to use after the next tick interrupt. */
	ullNextTime += ( uint64_t ) uxTimerIncrementsForOneTick;

	/* Enable mtime interrupt */
	__asm volatile( "csrs mie,%0" :: "r"(0x80) );
}
/*-----------------------------------------------------------*/

__ilm__ void FreeRTOS_tick_handler( void )
{
	/* Update the mtimer compare match value. */
	prvWriteMtimecmp( ullNextTime );

	/* Add ullNextTime to the timer increments for one tick. */
	ullNextTime += ( uint64_t ) uxTimerIncrementsForOneTick;

	if( xTaskIncrementTick() != pdFALSE )
	{
		vTaskSwitchContext();
	}

	#if( configUSE_TICKLESS_IDLE != 0 )
		xTickFlag = pdTRUE;
	#endif /* configUSE_TICKLESS_IDLE */
}
/*-----------------------------------------------------------*/
