/*
 * Copyright 2018-2024 Senscomm Semiconductor Co., Ltd.	All rights reserved.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#include <hal/kernel.h>
#include <hal/device.h>
#include <hal/console.h>
#include <hal/machine.h>
#include <hal/timer.h>
#include <hal/init.h>

#include <FreeRTOS/FreeRTOS.h>
#include <soc.h>
#include <cli.h>

#include "cmsis_os.h"

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <gcov.h>
#include <version.h>

extern FILE *stdin, *stdout, *stderr;
extern int time_hz;

/* Pick up the first hw timer and use it as free running clock */
void __weak hal_timer_init(void)
{
	struct device *timer = device_get_by_name("timer.0");
	if (!timer) {
		printk("timer not found\n");
	}
	device_bind_driver(timer, NULL);

	timer_setup(timer, 0, HAL_TIMER_FREERUN, time_hz, NULL, NULL);
	timer_start(timer, 0);
	register_timer(timer);
}

/*
 * main() - fictitious main()
 *
 * This function does nothing and turns the init thread into
 * the command-line interface processing thread.
 */
__weak int main(void)
{
	return 0;
}

__weak int sync_ipc(void)
{
	return 0;
}

typedef void (*func_ptr)();

#ifdef CONFIG_CPP_STATIC_INIT
extern func_ptr __init_array_start[];
extern func_ptr __init_array_end[];

static void call_global_constructors() {
#if 0
    printk("[%s, %d] __init_array_start: 0x%x\n", __func__, __LINE__, __init_array_start);
    printk("[%s, %d] __init_array_end: 0x%x\n", __func__, __LINE__, __init_array_end);
#endif
    if ((u32)__init_array_start >= (u32)__init_array_end)
        return;

    for (func_ptr* p = __init_array_start; p != __init_array_end; ++p) {
#if 0
        printf("[%s, %d] p: 0x%x\n", __func__, __LINE__, p);
#endif
        (*p)();
    }
}
#endif

#include <generated/version_autogenerated.h>

#define xstr(s) str(s)
#define str(s) #s
#define SERIAL_CONSOLE "/dev/ttyS" xstr(CONFIG_SERIAL_CONSOLE_PORT)

static void init(void *param)
{
	printk("%s %s\n", WISE_VERSION, CC_VERSION_STRING);

#ifdef CONFIG_SUPPORT_GCOV
	gcov_init();
#endif

	board_init();
	hal_timer_init();
	hal_init(subsystem);
	driver_init();
	soc_init();
	hal_init(filesystem);

#ifdef CONFIG_FS

	/* Prepare stdin, stdout, and stderr */
	os_open(SERIAL_CONSOLE, O_RDWR, 0);
	os_dup(0);
	os_dup(0);

	stdin = os_fdopen(0, "r");
	stdout = os_fdopen(1, "w");
	stderr = os_fdopen(2, "w");

#endif

	sync_ipc();

	printf("\x1b[2J\x1b[1;1H%s\n", version_string);

#ifdef CONFIG_CPP_STATIC_INIT
    call_global_constructors();
#endif

	/* Calls to main() if there is one, or weak main() declared above */
	main();

#ifdef CONFIG_CMDLINE
	/*
	 * If main() function ever returns, we choose to start command-line
	 * interface.
	 *
	 * NB: I have no clear idea how to make project main() and cli
	 * coexist and switch between each other.
	 */
	do {
		extern void cli_loop(void);

		cli_loop();
	} while (0);
#else
	while (1) osDelay(pdMS_TO_TICKS(100));
#endif
	assert(0); /* should not come here */
}

void start_kernel(void)
{
#ifdef CONFIG_CMSIS_FREERTOS

	osThreadAttr_t attr = {
		.name 		= "init",
		.stack_size 	= 1024 * 4,
		.priority 	= osPriorityNormal,
	};

	hal_init(arch);
	hal_init(early);

	osKernelInitialize();

	if (!osThreadNew(init, NULL, &attr))
		printk("%s: failed to create init task\n", __func__);

	osKernelStart();

#else

	init(NULL);

#endif
}
